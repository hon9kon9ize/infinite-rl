name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  workflow_dispatch: # Manual trigger only

permissions:
  actions: write
  statuses: write

jobs:
  version-check:
    runs-on: ubuntu-latest
    outputs:
      release_exists: ${{ steps.check_release.outputs.release_exists }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine package version
        id: get_version
        shell: bash
        run: |
          set -e
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          echo "PWD=$(pwd)"
          echo "Listing repository root:"
          ls -la "$GITHUB_WORKSPACE" || true

          # Prefer explicit workspace path to avoid issues when working-directory changes
          if [ -f "$GITHUB_WORKSPACE/VERSION.txt" ]; then
            VERSION_RAW=$(cat "$GITHUB_WORKSPACE/VERSION.txt" | tr -d "\n\r " )
          elif [ -f VERSION.txt ]; then
            VERSION_RAW=$(cat VERSION.txt | tr -d "\n\r " )
          else
            echo "ERROR: VERSION.txt not found in repository root (checked $GITHUB_WORKSPACE and PWD)."
            exit 1
          fi

          [[ "$VERSION_RAW" == v* ]] && VERSION="$VERSION_RAW" || VERSION="v$VERSION_RAW"
          echo "Found version: $VERSION"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Check for existing release
        id: check_release
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="runtimes-${{ steps.get_version.outputs.version }}"
          resp=$(curl -sS -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG" || true)
          if echo "$resp" | jq -e '.id' >/dev/null 2>&1; then
            echo "release_exists=true" >> "$GITHUB_OUTPUT"
            echo "upload_url=$(echo "$resp" | jq -r '.upload_url' | sed 's/{?name,label}//')" >> "$GITHUB_OUTPUT"
          else
            echo "release_exists=false" >> "$GITHUB_OUTPUT"
          fi

  test:
    needs: version-check
    # Only run when this is not a workflow_run event OR when the triggering workflow succeeded
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Exit if release missing
        if: ${{ needs.version-check.outputs.release_exists == 'false' }}
        run: |
          echo "Release runtimes-${{ needs.version-check.outputs.version }} not found. Exiting CI run."
          exit 0

      - name: Continue when release present
        if: ${{ needs.version-check.outputs.release_exists == 'true' }}
        uses: actions/checkout@v4

      - name: Set up Python
        if: ${{ needs.version-check.outputs.release_exists == 'true' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install system dependencies
        if: ${{ needs.version-check.outputs.release_exists == 'true' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y nodejs openjdk-17-jdk g++

      - name: Install Python package from git (will trigger build and download runtimes)
        if: ${{ needs.version-check.outputs.release_exists == 'true' }}
        env:
          # Tell setup.py which release tag to fetch runtimes from (version is like 'vX.Y.Z')
          RUNTIME_RELEASE_TAG: ${{ needs.version-check.outputs.version }}
          # Allow override of repo if needed (defaults to package value)
          RUNTIME_GITHUB_REPO: ${{ github.repository }}
          # Provide token to avoid GitHub API rate limits when discovering/downloading runtimes
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python -m pip install --upgrade pip
          # Install from the corresponding runtimes release tag (e.g., runtimes-v0.1.16)
          # This builds a wheel and triggers our build-time hook to bundle runtimes into the wheel.
          pip install git+https://github.com/${{ github.repository }}@runtimes-${{ needs.version-check.outputs.version }}
          pip install pytest pytest-cov pytest-html

      - name: Verify runtime assets were downloaded
        if: ${{ needs.version-check.outputs.release_exists == 'true' }}
        run: |
          python - <<'PY'
          import infinite_rl
          import os

          runtimes_dir = os.path.join(os.path.dirname(infinite_rl.__file__), 'runtimes')
          print(f'Checking runtimes directory: {runtimes_dir}')

          if not os.path.exists(runtimes_dir):
              print('ERROR: Runtimes directory does not exist!')
              exit(1)

          contents = sorted(os.listdir(runtimes_dir))
          print(f'Contents: {contents}')

          required_files = ['math.json', 'puzzle_js.wasm', 'puzzles.json']
          missing_files = [f for f in required_files if f not in contents]

          if missing_files:
              print(f'ERROR: Missing required runtime files: {missing_files}')
              exit(1)

          # Verify files are not empty
          for filename in required_files:
              filepath = os.path.join(runtimes_dir, filename)
              size = os.path.getsize(filepath)
              print(f'  {filename}: {size:,} bytes')
              if size == 0:
                  print(f'ERROR: {filename} is empty!')
                  exit(1)

          print('âœ“ All runtime assets verified successfully!')
          PY

      - name: Run unit tests with coverage
        if: ${{ needs.version-check.outputs.release_exists == 'true' }}
        run: |
          python -m pytest tests --cov=infinite_rl --cov-report=html --cov-report=xml --cov-report=term-missing --cov-fail-under=80

      - name: Set coverage status check
        if: ${{ needs.version-check.outputs.release_exists == 'true' && always() }}
        shell: bash
        run: |
          # Extract coverage percentage from coverage.xml if it exists
          COVERAGE="0"
          if [ -f coverage.xml ]; then
            COVERAGE=$(python3 -c 'import xml.etree.ElementTree as ET; tree = ET.parse("coverage.xml"); root = tree.getroot(); coverage_elem = root.find(".//coverage"); print(round(float(coverage_elem.get("line-rate", "0")) * 100) if coverage_elem is not None else 0)')
          fi

          # Set GitHub status check
          if [ "$COVERAGE" -ge 80 ]; then
            STATE="success"
            DESCRIPTION="Coverage: ${COVERAGE}%"
          else
            STATE="failure"
            DESCRIPTION="Coverage too low: ${COVERAGE}% (minimum 80%)"
          fi

          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -d "{
              \"state\": \"$STATE\",
              \"description\": \"$DESCRIPTION\",
              \"context\": \"code-coverage\",
              \"target_url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
            }"

      - name: Update coverage badge in README
        if: ${{ needs.version-check.outputs.release_exists == 'true' && github.ref == 'refs/heads/main' }}
        run: |
          python tests/update_coverage_badge.py

  schedule_retry:
    needs: version-check
    if: ${{ needs.version-check.outputs.release_exists == 'false' }}
    runs-on: ubuntu-latest
    steps:
      - name: Wait 5 minutes
        run: sleep 300

      - name: Trigger CI workflow after delay
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Triggering CI workflow dispatch for main branch"
          curl -X POST -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $GITHUB_TOKEN" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/ci.yml/dispatches \
            -d '{"ref":"main"}'
