#!/usr/bin/env python3
"""
Script to generate LLM prompts for individual puzzles in JavaScript or Python format.

This script extracts puzzle information from the generator files and formats
prompts similar to the llm_instructions.md generated by generate_instructions.js.
"""

import os
import re
from pathlib import Path
import json
import sys
import importlib

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

print("Current dir:", os.getcwd())
print("Script dir:", os.path.dirname(__file__))
print("Project root:", os.path.dirname(os.path.dirname(__file__)))
print("Python path:", sys.path)

# Directory paths
project_root = Path(os.path.dirname(os.path.dirname(__file__)))
js_generators_dir = project_root / "build_src" / "js_puzzles" / "generators"
python_generators_dir = project_root / "infinite_rl" / "python_puzzles" / "generators"


def extract_js_puzzle_info(file_path, puzzle_name):
    """Extract puzzle information from a JavaScript generator file."""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
    except:
        return None

    # Find the class
    class_match = re.search(
        rf"export class {re.escape(puzzle_name)} extends PuzzleGenerator", content
    )
    if not class_match:
        return None

    class_start = class_match.end()

    # Find next class or end
    next_class_match = re.search(
        r"export class \w+ extends PuzzleGenerator", content[class_start:]
    )
    class_end = class_start + (
        next_class_match.start() if next_class_match else len(content[class_start:])
    )

    class_content = content[class_start:class_end]

    # Extract docstring
    docstring_match = re.search(
        r'static docstring = ["\']([^"\']*)["\']', class_content
    )
    docstring = docstring_match.group(1) if docstring_match else ""
    docstring = docstring.replace(r"\n", "\n").replace(r"\t", "\t")

    # Extract sat function
    sat_match = re.search(
        r"static sat \([^}]*(?:\{[^}]*\}[^}]*)*\}", class_content, re.DOTALL
    )
    sat = sat_match.group(0).replace("static sat", "function sat") if sat_match else ""

    # Extract sol function header
    sol_match = re.search(r"static sol \([^)]*\)", class_content)
    sol = sol_match.group(0).replace("static sol", "function sol") if sol_match else ""

    # Extract getExample and update sol parameters
    example_match = re.search(
        r"getExample \(\) \{\s*return (\{[^}]*\}|\[[^\]]*\]);?\s*\}", class_content
    )
    if example_match and sol:
        try:
            example_obj = eval("(" + example_match[1] + ")")
            if isinstance(example_obj, dict):
                params = ", ".join(f"{k} = {repr(v)}" for k, v in example_obj.items())
            elif isinstance(example_obj, list):
                # For lists, find the first parameter name from sat function
                sat_params_match = re.search(r"static sat \(([^)]*)\)", class_content)
                if sat_params_match:
                    param_names = [
                        p.strip().split("=")[0].strip()
                        for p in sat_params_match[1].split(",")
                        if p.strip()
                    ]
                    if param_names:
                        params = f"{param_names[0]} = {repr(example_obj)}"
                    else:
                        params = ""
                else:
                    params = ""
            else:
                params = ""
            if params:
                sol = f"function sol({params})"
        except:
            pass  # Keep original sol if parsing fails

    return {"docstring": docstring, "sat": sat, "sol": sol, "ans_type": None}


def extract_python_puzzle_info(file_path, puzzle_name):
    """Extract puzzle information from a Python generator file."""
    try:
        # Import the module and get the class
        module_name = file_path.stem
        module = importlib.import_module(
            f"infinite_rl.python_puzzles.generators.{module_name}"
        )
        cls = getattr(module, puzzle_name)
        gen = cls()

        docstring = gen.docstring
        sat_code = gen.sat_src
        ans_type = gen.ans_type

        # Generate sol header from arg_names
        if gen.arg_names and len(gen.arg_names) > 1:
            sol_args = ", ".join(gen.arg_names[1:])
            sol = f"def sol({sol_args}):"
        else:
            sol = "def sol():"

        return {
            "docstring": docstring,
            "sat": sat_code,
            "sol": sol,
            "ans_type": ans_type,
        }
    except Exception as e:
        print(f"Error extracting info for {puzzle_name}: {e}")
        return None


def get_available_puzzles(language="javascript"):
    """
    Get a list of available puzzle names for the specified language.

    Args:
        language (str): "javascript" or "python"

    Returns:
        list: List of puzzle names available for the language
    """
    puzzles = []

    if language == "javascript":
        # Search JS generator files
        for file_path in js_generators_dir.glob("*.js"):
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
                # Find all class names
                class_matches = re.findall(
                    r"export class (\w+) extends PuzzleGenerator", content
                )
                puzzles.extend(class_matches)
            except:
                continue

    elif language == "python":
        # Search Python generator files
        for file_path in python_generators_dir.glob("*.py"):
            if file_path.name != "__init__.py":
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        content = f.read()
                    # Find all class names
                    class_matches = re.findall(
                        r"class (\w+)\(PuzzleGenerator\):", content
                    )
                    puzzles.extend(class_matches)
                except:
                    continue

    return sorted(list(set(puzzles)))  # Remove duplicates and sort


def generate_puzzle_assets(output_dir="assets"):
    """
    Generate a single JSON asset file containing all puzzle information.

    Args:
        output_dir (str): Directory to save the JSON file
    """
    os.makedirs(output_dir, exist_ok=True)

    # Load ratings
    ratings_file = project_root / "build_src" / "puzzle_ratings.json"
    ratings = {}
    if ratings_file.exists():
        with open(ratings_file, "r", encoding="utf-8") as f:
            ratings_data = json.load(f)
            for item in ratings_data:
                ratings[item["puzzle_name"]] = item["rating"]
        print(f"Loaded ratings for {len(ratings)} puzzles")
    else:
        print("Warning: puzzle_ratings.json not found, ratings will be None")

    languages = ["javascript", "python"]
    all_puzzles = {"javascript": {}, "python": {}}

    # First, collect Python ans_types
    python_ans_types = {}
    for file_path in python_generators_dir.glob("*.py"):
        if file_path.name != "__init__.py":
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
                # Find all class names
                class_matches = re.findall(r"class (\w+)\(PuzzleGenerator\):", content)
                for puzzle_name in class_matches:
                    info = extract_python_puzzle_info(file_path, puzzle_name)
                    if info and info["ans_type"]:
                        python_ans_types[puzzle_name] = info["ans_type"]
            except:
                continue

    # Type mapping from Python to JavaScript
    type_map = {
        "int": "number",
        "float": "number",
        "str": "string",
        "bool": "boolean",
        "List": "Array",
    }

    for language in languages:
        puzzles = get_available_puzzles(language)

        for puzzle_name in puzzles:
            if language == "javascript":
                # Search JS generator files
                for file_path in js_generators_dir.glob("*.js"):
                    info = extract_js_puzzle_info(file_path, puzzle_name)
                    if info:
                        # Get ans_type from Python version
                        py_ans_type = python_ans_types.get(puzzle_name, "any")
                        ans_type = type_map.get(py_ans_type, py_ans_type)
                        all_puzzles[language][puzzle_name] = {
                            "name": puzzle_name,
                            "language": language,
                            "docstring": info["docstring"],
                            "sat": info["sat"],
                            "sol": info["sol"],
                            "ans_type": ans_type,
                            "rating": ratings.get(puzzle_name, None),
                        }
                        print(f"Processed {language}/{puzzle_name}")
                        break
            elif language == "python":
                # Search Python generator files
                for file_path in python_generators_dir.glob("*.py"):
                    if file_path.name != "__init__.py":
                        info = extract_python_puzzle_info(file_path, puzzle_name)
                        if info:
                            all_puzzles[language][puzzle_name] = {
                                "name": puzzle_name,
                                "language": language,
                                "docstring": info["docstring"],
                                "sat": info["sat"],
                                "sol": info["sol"],
                                "ans_type": info["ans_type"],
                                "rating": ratings.get(puzzle_name, None),
                            }
                            break

    output_file = Path(output_dir) / "puzzles.json"
    with open(output_file, "w", encoding="utf-8") as f:
        json.dump(all_puzzles, f, indent=2, ensure_ascii=False)

    print(f"Generated {output_file}")


if __name__ == "__main__":
    # Generate puzzle assets
    generate_puzzle_assets()
