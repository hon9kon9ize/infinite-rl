from typing import Union, Callable, Dict, Any
from .reward_function import RewardFunction, RewardFunctionScore
from bs4 import BeautifulSoup


class HtmlRewardFunction(RewardFunction):
    """Reward function for evaluating LLM-generated HTML solutions."""

    def __init__(self, task_name: str = "html"):
        super().__init__(task_name)

    def initialize(self):
        """Initialize the HTML reward function."""
        self.initialized = True

    def compute_reward(
        self,
        model_output: str,
        expected_output: Union[str, Dict[str, Any], Callable],
    ) -> RewardFunctionScore:
        """
        Compute reward for generated HTML.

        Args:
            model_output: The HTML code generated by the LLM
            expected_output: The reference/expected HTML structure
                - str: CSS selector or expected HTML substring to match
                - dict: Contains 'selectors' (list of CSS selectors to match)
                        or 'expected_html' (HTML substring to find)
                - Callable: Custom validation function

        Returns:
            RewardFunctionScore with format_score (syntax validity) and correctness_score (selector match: 0 or 1)
        """
        if not self.initialized:
            self.initialize()

        # Try to parse the HTML
        try:
            soup = BeautifulSoup(model_output, "html.parser")
            format_score = 1.0  # Valid HTML syntax
        except Exception as e:
            # Invalid HTML syntax
            return RewardFunctionScore(format_score=0.0, correctness_score=0.0)

        # Handle different expected_output types
        if callable(expected_output):
            # Callable: pass soup object to validator function
            try:
                result = expected_output(soup)
                if isinstance(result, bool):
                    correctness_score = 1.0 if result else 0.0
                elif isinstance(result, float):
                    correctness_score = 1.0 if result > 0.5 else 0.0
                else:
                    correctness_score = 0.0
                return RewardFunctionScore(
                    format_score=format_score, correctness_score=correctness_score
                )
            except Exception as e:
                return RewardFunctionScore(
                    format_score=format_score, correctness_score=0.0
                )

        elif isinstance(expected_output, dict):
            # Dict: check selectors or expected HTML
            selectors = expected_output.get("selectors", [])
            expected_html = expected_output.get("expected_html", None)

            all_matched = True
            total = 0

            # Check CSS selectors - all must match
            if selectors:
                total = len(selectors)
                for selector in selectors:
                    try:
                        elements = soup.select(selector)
                        if not elements:
                            all_matched = False
                            break
                    except Exception:
                        all_matched = False
                        break

            # Check expected HTML substring
            if expected_html and all_matched:
                if expected_html not in model_output:
                    all_matched = False
                total += 1

            correctness_score = 1.0 if all_matched and total > 0 else 0.0
            return RewardFunctionScore(
                format_score=format_score, correctness_score=correctness_score
            )

        else:
            # String: treat as CSS selector
            selector = str(expected_output)
            try:
                elements = soup.select(selector)
                correctness_score = 1.0 if elements else 0.0
                return RewardFunctionScore(
                    format_score=format_score, correctness_score=correctness_score
                )
            except Exception:
                return RewardFunctionScore(
                    format_score=format_score, correctness_score=0.0
                )
